{
    "dsa_patterns": [
      {
        "id": 1,
        "name": "Prefix Sum",
        "description": "Preprocessing an array to create a new array where each element at index i represents the sum of the array from the start up to i. This allows for efficient sum queries on subarrays.",
        "when_to_use": "When you need to perform multiple sum queries on a subarray or need to calculate cumulative sums efficiently.",
        "key_concepts": "Build a prefix sum array where each element contains the sum from start to current index. Use formula: sum(i,j) = prefix[j] - prefix[i-1].",
        "time_complexity": "O(n)",
        "space_complexity": "O(n)",
        "sample_problem": "Given an array nums, answer multiple queries about the sum of elements within a specific range [i, j].",
        "detailed_explanation": "The Prefix Sum technique is a preprocessing method that allows us to answer range sum queries in constant time after O(n) preprocessing. We create an auxiliary array where prefix[i] = sum of elements from index 0 to i. This transforms range queries from O(n) to O(1).",
        "youtube_video": "https://www.youtube.com/watch?v=pVS3yhlzrlQ",
        "visual_example": {
          "array": [1, 2, 3, 4, 5, 6],
          "prefix_sum": [1, 3, 6, 10, 15, 21],
          "query_range": [1, 3],
          "result": "prefix[3] - prefix[0] = 10 - 1 = 9"
        },
        "implementation_steps": [
          "Create prefix sum array of same size",
          "Set prefix[0] = arr[0]",
          "For i from 1 to n-1: prefix[i] = prefix[i-1] + arr[i]",
          "For range query (i,j): return prefix[j] - prefix[i-1]"
        ],
        "common_variations": [
          "2D Prefix Sum for matrix range queries",
          "Prefix XOR for XOR range queries",
          "Prefix product for product range queries"
        ],
        "leetcode_problems": [
          {"name": "Range Sum Query - Immutable", "number": 303, "difficulty": "Easy", "url": "https://leetcode.com/problems/range-sum-query-immutable/"},
          {"name": "Contiguous Array", "number": 525, "difficulty": "Medium", "url": "https://leetcode.com/problems/contiguous-array/"},
          {"name": "Subarray Sum Equals K", "number": 560, "difficulty": "Medium", "url": "https://leetcode.com/problems/subarray-sum-equals-k/"},
          {"name": "Range Sum Query 2D - Immutable", "number": 304, "difficulty": "Medium", "url": "https://leetcode.com/problems/range-sum-query-2d-immutable/"},
          {"name": "Subarray Sums Divisible by K", "number": 974, "difficulty": "Medium", "url": "https://leetcode.com/problems/subarray-sums-divisible-by-k/"}
        ]
      },
      {
        "id": 2,
        "name": "Two Pointers",
        "description": "Using two pointers to iterate through an array or list, often used to find pairs or elements that meet specific criteria.",
        "when_to_use": "When dealing with sorted arrays or lists where you need to find pairs that satisfy a specific condition, or when you need to process elements from both ends.",
        "key_concepts": "Use two pointers moving towards each other or in the same direction. Adjust pointer movement based on current sum/condition compared to target.",
        "time_complexity": "O(n)",
        "space_complexity": "O(1)",
        "sample_problem": "Find two numbers in a sorted array that add up to a target value.",
        "detailed_explanation": "Two Pointers is an efficient technique for solving problems involving arrays or linked lists. It uses two pointers that move through the data structure in a coordinated way, often from opposite ends or at different speeds. This approach can reduce time complexity from O(n²) to O(n) for many problems.",
        "youtube_video": "https://www.youtube.com/watch?v=On03HWe2tZM",
        "visual_example": {
          "array": [1, 2, 3, 4, 5, 6],
          "left_pointer": 0,
          "right_pointer": 5,
          "target": 7,
          "steps": "left=0, right=5: 1+6=7 Found!"
        },
        "implementation_steps": [
          "Initialize left pointer at start (0) and right pointer at end (n-1)",
          "While left < right:",
          "  Calculate current sum = arr[left] + arr[right]",
          "  If sum equals target: return [left, right]",
          "  If sum < target: move left pointer right (left++)",
          "  If sum > target: move right pointer left (right--)"
        ],
        "common_variations": [
          "Fast and Slow pointers for cycle detection",
          "Three pointers for 3Sum problems",
          "Sliding window with two pointers",
          "Opposite direction pointers for palindrome checking"
        ],
        "leetcode_problems": [
          {"name": "Two Sum II - Input array is sorted", "number": 167, "difficulty": "Easy", "url": "https://leetcode.com/problems/two-sum-ii-input-array-is-sorted/"},
          {"name": "3Sum", "number": 15, "difficulty": "Medium", "url": "https://leetcode.com/problems/3sum/"},
          {"name": "Container With Most Water", "number": 11, "difficulty": "Medium", "url": "https://leetcode.com/problems/container-with-most-water/"},
          {"name": "Remove Duplicates from Sorted Array", "number": 26, "difficulty": "Easy", "url": "https://leetcode.com/problems/remove-duplicates-from-sorted-array/"},
          {"name": "Trapping Rain Water", "number": 42, "difficulty": "Hard", "url": "https://leetcode.com/problems/trapping-rain-water/"}
        ]
      },
      {
        "id": 3,
        "name": "Sliding Window",
        "description": "Used to find a subarray or substring that satisfies a specific condition, optimizing the time complexity by maintaining a window of elements.",
        "when_to_use": "When dealing with problems involving contiguous subarrays or substrings.",
        "key_concepts": "Maintain a window of elements and slide it through the array. Expand or shrink window based on conditions.",
        "time_complexity": "O(n)",
        "space_complexity": "O(1)",
        "sample_problem": "Find the maximum sum of a subarray of size k.",
        "detailed_explanation": "The Sliding Window technique involves maintaining a subset of items as a window and sliding this window within a larger set of items to find a solution. This technique reduces time complexity from O(n²) to O(n) for many problems.",
        "youtube_video": "https://www.youtube.com/watch?v=MK-NZ4hN7rs",
        "example": {
          "input": "nums = [2, 1, 5, 1, 3, 2], k = 3",
          "output": "9",
          "explanation": "Start with the sum of the first k elements. Slide the window one element at a time, subtracting the element that goes out of the window and adding the new element. Keep track of the maximum sum encountered."
        },
        "leetcode_problems": [
          {"name": "Maximum Average Subarray I", "number": 643, "difficulty": "Easy", "url": "https://leetcode.com/problems/maximum-average-subarray-i/"},
          {"name": "Longest Substring Without Repeating Characters", "number": 3, "difficulty": "Medium", "url": "https://leetcode.com/problems/longest-substring-without-repeating-characters/"},
          {"name": "Minimum Window Substring", "number": 76, "difficulty": "Hard", "url": "https://leetcode.com/problems/minimum-window-substring/"}
        ]
      },
      {
        "id": 4,
        "name": "Fast & Slow Pointers",
        "description": "The Tortoise and Hare pattern is used to detect cycles in linked lists and other similar structures.",
        "when_to_use": "When you need to detect cycles or find middle elements in linked structures.",
        "key_concepts": "Use two pointers moving at different speeds. Fast pointer moves 2 steps, slow pointer moves 1 step.",
        "time_complexity": "O(n)",
        "space_complexity": "O(1)",
        "sample_problem": "Detect if a linked list has a cycle.",
        "detailed_explanation": "Also known as Floyd's Cycle Detection Algorithm, this technique uses two pointers moving at different speeds to detect cycles in linked structures. If there's a cycle, the fast pointer will eventually meet the slow pointer.",
        "youtube_video": "https://www.youtube.com/watch?v=zbozWoMgKW0",
        "example": {
          "input": "Linked list with cycle",
          "output": "true/false",
          "explanation": "Initialize two pointers, one moving one step at a time (slow) and the other moving two steps at a time (fast). If there is a cycle, the fast pointer will eventually meet the slow pointer. If the fast pointer reaches the end of the list, there is no cycle."
        },
        "leetcode_problems": [
          {"name": "Linked List Cycle", "number": 141, "difficulty": "Easy", "url": "https://leetcode.com/problems/linked-list-cycle/"},
          {"name": "Happy Number", "number": 202, "difficulty": "Easy", "url": "https://leetcode.com/problems/happy-number/"},
          {"name": "Find the Duplicate Number", "number": 287, "difficulty": "Medium", "url": "https://leetcode.com/problems/find-the-duplicate-number/"}
        ]
      },
      {
        "id": 5,
        "name": "LinkedList In-place Reversal",
        "description": "Reverses parts of a linked list without using extra space.",
        "when_to_use": "When you need to reverse sections of a linked list.",
        "key_concepts": "Use three pointers: previous, current, and next. Reverse links by changing pointer directions.",
        "time_complexity": "O(n)",
        "space_complexity": "O(1)",
        "sample_problem": "Reverse a sublist of a linked list from position m to n.",
        "detailed_explanation": "This pattern involves reversing a linked list in-place by iteratively changing the direction of pointers. It's memory efficient as it doesn't require extra space for storing nodes.",
        "youtube_video": "https://www.youtube.com/watch?v=D7y_hoT_YZI",
        "example": {
          "input": "head = [1, 2, 3, 4, 5], m = 2, n = 4",
          "output": "[1, 4, 3, 2, 5]",
          "explanation": "Identify the start and end of the sublist. Reverse the nodes in place by adjusting the pointers."
        },
        "leetcode_problems": [
          {"name": "Reverse Linked List", "number": 206, "difficulty": "Easy", "url": "https://leetcode.com/problems/reverse-linked-list/"},
          {"name": "Reverse Linked List II", "number": 92, "difficulty": "Medium", "url": "https://leetcode.com/problems/reverse-linked-list-ii/"},
          {"name": "Swap Nodes in Pairs", "number": 24, "difficulty": "Medium", "url": "https://leetcode.com/problems/swap-nodes-in-pairs/"}
        ]
      },
      {
        "id": 6,
        "name": "Monotonic Stack",
        "description": "Uses a stack to maintain a sequence of elements in a specific order (increasing or decreasing).",
        "when_to_use": "For problems that require finding the next greater or smaller element.",
        "key_concepts": "Maintain stack in monotonic order. Pop elements when current element breaks the monotonic property.",
        "time_complexity": "O(n)",
        "space_complexity": "O(n)",
        "sample_problem": "Find the next greater element for each element in an array. Output -1 if the greater element doesn't exist.",
        "detailed_explanation": "A monotonic stack maintains elements in a specific order (increasing or decreasing). It's useful for problems involving finding the next greater/smaller element, as it allows us to process each element exactly once.",
        "youtube_video": "https://www.youtube.com/watch?v=Dq_ObZwTY_Q",
        "example": {
          "input": "nums = [2, 1, 2, 4, 3]",
          "output": "[4, 2, 4, -1, -1]",
          "explanation": "Use a stack to keep track of elements for which we haven't found the next greater element yet. Iterate through the array, and for each element, pop elements from the stack until you find a greater element. If the stack is not empty, set the result for index at the top of the stack to current element. Push the current element onto the stack."
        },
        "leetcode_problems": [
          {"name": "Next Greater Element I", "number": 496, "difficulty": "Easy", "url": "https://leetcode.com/problems/next-greater-element-i/"},
          {"name": "Daily Temperatures", "number": 739, "difficulty": "Medium", "url": "https://leetcode.com/problems/daily-temperatures/"},
          {"name": "Largest Rectangle in Histogram", "number": 84, "difficulty": "Hard", "url": "https://leetcode.com/problems/largest-rectangle-in-histogram/"}
        ]
      },
      {
        "id": 7,
        "name": "Top 'K' Elements",
        "description": "Finds the top k largest or smallest elements in an array or stream of data using heaps or sorting.",
        "when_to_use": "When you need to find k largest/smallest elements efficiently.",
        "key_concepts": "Use heaps (priority queues) to maintain top K elements. Min-heap for K largest, max-heap for K smallest.",
        "time_complexity": "O(n log k)",
        "space_complexity": "O(k)",
        "sample_problem": "Find the k-th largest element in an unsorted array.",
        "detailed_explanation": "This pattern uses heaps to efficiently find the top K elements. By maintaining a heap of size K, we can process large datasets while using minimal memory and achieving better time complexity than sorting.",
        "youtube_video": "https://www.youtube.com/watch?v=hOjcdrqMoQ8",
        "example": {
          "input": "nums = [3, 2, 1, 5, 6, 4], k = 2",
          "output": "5",
          "explanation": "Use a min-heap of size k to keep track of the k largest elements. Iterate through the array, adding elements to the heap. If the heap size exceeds k, remove the smallest element from the heap. The root of the heap will be the k-th largest element."
        },
        "leetcode_problems": [
          {"name": "Kth Largest Element in an Array", "number": 215, "difficulty": "Medium", "url": "https://leetcode.com/problems/kth-largest-element-in-an-array/"},
          {"name": "Top K Frequent Elements", "number": 347, "difficulty": "Medium", "url": "https://leetcode.com/problems/top-k-frequent-elements/"},
          {"name": "Find K Pairs with Smallest Sums", "number": 373, "difficulty": "Medium", "url": "https://leetcode.com/problems/find-k-pairs-with-smallest-sums/"}
        ]
      },
      {
        "id": 8,
        "name": "Overlapping Intervals",
        "description": "Used to merge or handle overlapping intervals in an array.",
        "when_to_use": "When working with interval scheduling, merging, or overlap detection problems.",
        "key_concepts": "Sort intervals by start time. Two intervals [a,b] and [c,d] overlap if b >= c.",
        "time_complexity": "O(n log n)",
        "space_complexity": "O(1)",
        "sample_problem": "Merge all overlapping intervals.",
        "detailed_explanation": "This pattern deals with problems involving intervals. The key insight is to sort intervals by their start time, then iterate through them to detect overlaps and merge when necessary.",
        "youtube_video": "https://www.youtube.com/watch?v=qKczfGUrFY4",
        "example": {
          "input": "intervals = [[1, 3], [2, 6], [8, 10], [15, 18]]",
          "output": "[[1, 6], [8, 10], [15, 18]]",
          "explanation": "Sort the intervals by their start time. Create an empty list called merged to store the merged intervals. Iterate through the intervals and check if it overlaps with the last interval in the merged list. If it overlaps, merge the intervals by updating the end time of the last interval in merged. If it does not overlap, simply add the current interval to the merged list."
        },
        "leetcode_problems": [
          {"name": "Merge Intervals", "number": 56, "difficulty": "Medium", "url": "https://leetcode.com/problems/merge-intervals/"},
          {"name": "Insert Interval", "number": 57, "difficulty": "Medium", "url": "https://leetcode.com/problems/insert-interval/"},
          {"name": "Non-Overlapping Intervals", "number": 435, "difficulty": "Medium", "url": "https://leetcode.com/problems/non-overlapping-intervals/"}
        ]
      },
      {
        "id": 9,
        "name": "Modified Binary Search",
        "description": "Adapts binary search to solve a wider range of problems, such as finding elements in rotated sorted arrays.",
        "when_to_use": "For problems involving sorted or rotated arrays where you need to find a specific element.",
        "sample_problem": "Find an element in a rotated sorted array.",
        "image_url": "https://substackcdn.com/image/fetch/w_1456,c_limit,f_webp,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2Fb209ba23-9292-4254-b70b-968d6028cc82_1456x706.webp",
        "example": {
          "input": "nums = [4, 5, 6, 7, 0, 1, 2], target = 0",
          "output": "4",
          "explanation": "Perform binary search with an additional check to determine which half of the array is sorted. We then check if the target is within the range of the sorted half. If it is, we search that half; otherwise, we search the other half."
        },
        "leetcode_problems": [
          {"name": "Search in Rotated Sorted Array", "number": 33, "url": "https://leetcode.com/problems/search-in-rotated-sorted-array/description/"},
          {"name": "Find Minimum in Rotated Sorted Array", "number": 153, "url": "https://leetcode.com/problems/find-minimum-in-rotated-sorted-array/description/"},
          {"name": "Search a 2D Matrix II", "number": 240, "url": "https://leetcode.com/problems/search-a-2d-matrix-ii/description/"}
        ]
      },
      {
        "id": 10,
        "name": "Binary Tree Traversal",
        "description": "Involves visiting all the nodes in a binary tree in a specific order.",
        "when_to_use": "When you need to visit all nodes in a tree in a specific order.",
        "image_url": "https://substackcdn.com/image/fetch/w_1456,c_limit,f_webp,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2Feca7c694-9f06-4deb-a644-9939054fc5bc_1456x660.webp",
        "traversal_types": {
          "PreOrder": "root -> left -> right",
          "InOrder": "left -> root -> right",
          "PostOrder": "left -> right -> root"
        },
        "sample_problem": "Perform inorder traversal of a binary tree.",
        "example": {
          "input": "root = [1, null, 2, 3]",
          "output": "[1, 3, 2]",
          "explanation": "Inorder traversal visits nodes in the order: left, root, right. Use recursion or a stack to traverse the tree in this order."
        },
        "leetcode_problems": [
          {"name": "Binary Tree Paths", "number": 257, "type": "PreOrder", "url": "https://leetcode.com/problems/binary-tree-paths/description/"},
          {"name": "Kth Smallest Element in a BST", "number": 230, "type": "InOrder", "url": "https://leetcode.com/problems/kth-smallest-element-in-a-bst/description/"},
          {"name": "Binary Tree Maximum Path Sum", "number": 124, "type": "PostOrder", "url": "https://leetcode.com/problems/binary-tree-maximum-path-sum/description/"}
        ]
      },
      {
        "id": 11,
        "name": "Depth-First Search (DFS)",
        "description": "A traversal technique that explores as far down a branch as possible before backtracking.",
        "when_to_use": "For exploring all paths or branches in graphs or trees.",
        "sample_problem": "Find all paths from the root to leaves in a binary tree.",
        "image_url": "https://substackcdn.com/image/fetch/w_1456,c_limit,f_webp,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2Ff3a613af-74a9-4764-8e6e-297a40e15a42_1456x817.webp",
        "example": {
          "input": "root = [1, 2, 3, null, 5]",
          "output": "[\"1->2->5\", \"1->3\"]",
          "explanation": "Use recursion or a stack to traverse each path from the root to the leaves. Record each path as you traverse."
        },
        "leetcode_problems": [
          {"name": "Clone Graph", "number": 133, "url": "https://leetcode.com/problems/clone-graph/description/"},
          {"name": "Path Sum II", "number": 113, "url": "https://leetcode.com/problems/path-sum-ii/description/"},
          {"name": "Course Schedule II", "number": 210, "url": "https://leetcode.com/problems/course-schedule-ii/description/"}
        ]
      },
      {
        "id": 12,
        "name": "Breadth-First Search (BFS)",
        "description": "A traversal technique that explores nodes level by level in a tree or graph.",
        "when_to_use": "For finding the shortest paths in unweighted graphs or level-order traversal in trees.",
        "sample_problem": "Perform level-order traversal of a binary tree.",
        "image_url": "https://substackcdn.com/image/fetch/w_1456,c_limit,f_webp,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2Fc150796e-aae9-40c6-81fa-c014cbc29a13_1456x868.webp",
        "example": {
          "input": "root = [3, 9, 20, null, null, 15, 7]",
          "output": "[[3], [9, 20], [15, 7]]",
          "explanation": "Use a queue to keep track of nodes at each level. Traverse each level and add the children of the current nodes to the queue."
        },
        "leetcode_problems": [
          {"name": "Binary Tree Level Order Traversal", "number": 102, "url": "https://leetcode.com/problems/binary-tree-level-order-traversal/description/"},
          {"name": "Rotting Oranges", "number": 994, "url": "https://leetcode.com/problems/rotting-oranges/description/"},
          {"name": "Word Ladder", "number": 127, "url": "https://leetcode.com/problems/word-ladder/description/"}
        ]
      },
      {
        "id": 13,
        "name": "Matrix Traversal",
        "description": "Involves traversing elements in a matrix using different techniques (DFS, BFS, etc.).",
        "when_to_use": "For problems involving traversing 2D grids or matrices horizontally, vertically or diagonally.",
        "sample_problem": "Perform flood fill on a 2D grid. Change all the cells connected to the starting cell to new color.",
        "image_url": "https://substackcdn.com/image/fetch/w_1456,c_limit,f_webp,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2Fd228649e-0f35-480c-adf7-d31fb13940f7_1456x1525.webp",
        "example": {
          "input": "image = [[1,1,1],[1,1,0],[1,0,1]], sr = 1, sc = 1, newColor = 2",
          "output": "[[2,2,2],[2,2,0],[2,0,1]]",
          "explanation": "Use DFS or BFS to traverse the matrix starting from the given cell. Change the color of the connected cells to the new color."
        },
        "leetcode_problems": [
          {"name": "Flood Fill", "number": 733, "url": "https://leetcode.com/problems/flood-fill/description/"},
          {"name": "Number of Islands", "number": 200, "url": "https://leetcode.com/problems/number-of-islands/description/"},
          {"name": "Surrounded Regions", "number": 130, "url": "https://leetcode.com/problems/surrounded-regions/description/"}
        ]
      },
      {
        "id": 14,
        "name": "Backtracking",
        "description": "Explores all possible solutions and backtracks when a solution path fails.",
        "when_to_use": "When you need to find all (or some) solutions to a problem that satisfies given constraints. For example: combinatorial problems, such as generating permutations, combinations, or subsets.",
        "sample_problem": "Generate all permutations of a given list of numbers.",
        "image_url": "https://substackcdn.com/image/fetch/w_1456,c_limit,f_webp,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2F0e6aafdd-9b51-41ef-be18-c9d899c06c3a_1456x1448.webp",
        "example": {
          "input": "nums = [1, 2, 3]",
          "output": "[[1,2,3], [1,3,2], [2,1,3], [2,3,1], [3,1,2], [3,2,1]]",
          "explanation": "Use recursion to generate permutations. For each element, include it in the current permutation and recursively generate the remaining permutations. Backtrack when all permutations for a given path are generated."
        },
        "leetcode_problems": [
          {"name": "Permutations", "number": 46, "url": "https://leetcode.com/problems/permutations/description/"},
          {"name": "Subsets", "number": 78, "url": "https://leetcode.com/problems/subsets/description/"},
          {"name": "N-Queens", "number": 51, "url": "https://leetcode.com/problems/n-queens/description/"}
        ]
      },
      {
        "id": 15,
        "name": "Dynamic Programming Patterns",
        "description": "Involves breaking down problems into smaller subproblems and solving them using a bottom-up or top-down approach.",
        "when_to_use": "For problems with overlapping subproblems and optimal substructure.",
        "image_url": "https://substackcdn.com/image/fetch/w_1456,c_limit,f_webp,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2F80f6e7ac-1c6b-40a1-9730-88029e4894c2_1456x1372.webp",
        "sub_patterns": [
          "Fibonacci Numbers",
          "0/1 Knapsack",
          "Longest Common Subsequence (LCS)",
          "Longest Increasing Subsequence (LIS)",
          "Subset Sum",
          "Matrix Chain Multiplication"
        ],
        "sample_problem": "Calculate the n-th Fibonacci number.",
        "example": {
          "input": "n = 5",
          "output": "5 (The first five Fibonacci numbers are 0, 1, 1, 2, 3, 5)",
          "explanation": "Use a bottom-up approach to calculate the n-th Fibonacci number. Start with the first two numbers (0 and 1) and iterate to calculate the next numbers like (dp[i] = dp[i - 1] + dp[i - 2])."
        },
        "leetcode_problems": [
          {"name": "Climbing Stairs", "number": 70, "url": "https://leetcode.com/problems/climbing-stairs/description/"},
          {"name": "House Robber", "number": 198, "url": "https://leetcode.com/problems/house-robber/description/"},
          {"name": "Coin Change", "number": 322, "url": "https://leetcode.com/problems/coin-change/description/"},
          {"name": "Longest Common Subsequence (LCS)", "number": 1143, "url": "https://leetcode.com/problems/longest-common-subsequence/description/"},
          {"name": "Longest Increasing Subsequence (LIS)", "number": 300, "url": "https://leetcode.com/problems/longest-increasing-subsequence/description/"},
          {"name": "Partition Equal Subset Sum", "number": 416, "url": "https://leetcode.com/problems/partition-equal-subset-sum/description/"}
        ]
      }
    ]
  }